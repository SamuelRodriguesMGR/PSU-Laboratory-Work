<h1>Лабараторная работа 1 </h1>

<h2> Сумма знаков.</h2> 
Дана сигнатура метода: public int sumLastNums (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал результат
сложения двух последних знаков числах, предполагая, что знаков в числе не
менее двух. Подсказки:
int x=123%10; // х будет иметь значение 3
int у=123/10; // у будет иметь значение 12
Пример:
x=4568
результат: 14
<h2> Алгоритм решения </h2>
Получить последнюю цифру числа x с помощью операции x % 10.
Получить втярую цифру числа x с помощью операции (x / 10) % 10.
Сложить полученные цифры.
Вернуть результат сложения.

<h2> Есть ли позитив.</h2> 
Дана сигнатура метода: public bool isPositive (int x);
Необходимо реализовать метод таким образом, чтобы он принимал число x и
возвращал true, если оно положительное.
Пример 1:
x=3
результат: true
Пример 2:
x=-5
результат: false
<h2> Алгоритм решения </h2>
Сравнить число x с нулем.
Если x больше нуля, вернуть true.
В противном случае вернуть false.


<h2> Большая буква.</h2> 
Дана сигнатура метода: public bool isUpperCase (char x);
Необходимо реализовать метод таким образом, чтобы он принимал символ x и
возвращал true, если это большая буква в диапазоне от ‘A’ до ‘Z’.
Пример 1:
x=’D’
результат: true
Пример 2:
x=’q’
результат: false
<h2> Алгоритм решения </h2>
Сравнить символ x с символами от 'A' до 'Z'.
Если символ находится в этом диапазоне, вернуть true.
В противном случае вернуть false.


<h2> Делитель.</h2>  
Дана сигнатура метода: public bool isDivisor (int a, int b);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
любое из принятых чисел делит другое нацело.
Пример 1:
a=3 b=6
результат: true
Пример 2:
a=2 b=15
результат: false
<h2> Алгоритм решения </h2>
Проверить, делится ли число a на число b без остатка (a % b == 0).
Проверить, делится ли число b на число a без остатка (b % a == 0).
Если хотя бы одно из условий истинно, вернуть true.
В противном случае вернуть false.

<h2> Многократный вызов.</h2> 
Дана сигнатура метода: public int lastNumSum(int a, int b)
Необходимо реализовать метод таким образом, чтобы он считал сумму цифр
двух чисел из разряда единиц. Выполните с его помощью последовательное
сложение пяти чисел и результат выведите на экран. Постарайтесь выполнить
задачу, используя минимально возможное количество вспомогательных
переменных.
Пример:
5+11 это 6
6+123 это 9
9+14 это 13
13+1 это 4
Итого 4
<h2> Алгоритм решения </h2>
Получить последнюю цифру числа a с помощью операции a % 10.
Получить последнюю цифру числа b с помощью операции b % 10.
Сложить полученные цифры.
Вернуть результат сложения.
Алгоритм для последовательного сложения пяти чисел в Main:
Объявить переменную-аккумулятор (например, total).
Вызвать метод lastNumSum, передав total и первое число. Результат записать в total.
Повторить шаг 2 для оставшихся четырех чисел.
Вывести значение total на экран.

<h2> Безопасное деление.</h2> 
Дана сигнатура метода: public double safeDiv (int x, int y);
Необходимо реализовать метод таким образом, чтобы он возвращал деление x
на y, и при этом гарантировал, что не будет выкинута ошибка деления на 0. При
делении на 0 следует вернуть из метода число 0. Подсказка: смотри
ограничения на операции типов данных.
Пример 1:
x=5 y=0
результат: 0
Пример 2:
x=8 y=2
результат: 4
<h2> Алгоритм решения </h2>
Проверить, равен ли делитель y нулю.
Если y равен нулю, вернуть 0.
В противном случае выполнить деление x на y (желательно с приведением типов для вещественного результата) и вернуть его результат.


<h2> Строка сравнения.</h2> 
Дана сигнатура метода: public String makeDecision (int x, int y);
Необходимо реализовать метод таким образом, чтобы он возвращал строку,
которая включает два принятых методом числа и корректно выставленный
знак операции сравнения (больше, меньше, или равно).
Пример 1:
x=5 y=7
результат: “5< 7”
Пример 2:
x=8 y=-1
результат: “8 >-1”
Пример 3:
x=4 y=4
результат: “4==4”
<h2> Алгоритм решения </h2>
Сравнить числа x и y.
Если x больше y, сформировать и вернуть строку в формате "x > y".
Если x меньше y, сформировать и вернуть строку в формате "x < y".
Если x равен y, сформировать и вернуть строку в формате "x==y".


<h2> Тройная сумма.</h2> 
Дана сигнатура метода: public bool sum3 (int x, int y, int z);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
два любых числа (из трех принятых) можно сложить так, чтобы получить
третье.
Пример 1:
x=5 y=7 z=2
результат: true
Пример 2:
x=8 y=-1 z=4
результат: false
<h2> Алгоритм решения </h2>
Проверить, равна ли сумма x и y числу z.
Проверить, равна ли сумма x и z числу y.
Проверить, равна ли сумма y и z числу x.
Если хотя бы одна из проверок истинна, вернуть true.
В противном случае вернуть false.

<h2> Возраст.</h2> 
Дана сигнатура метода: public String age (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой сначала будет число х, а затем одно из слов:
год
года
лет
Слово “год” добавляется, если число х заканчивается на 1, кроме числа 11.
Слово “года” добавляется, если число х заканчивается на 2, 3 или 4, кроме чисел
12, 13, 14.
Слово “лет”добавляется во всех остальных случаях.
Подсказка: оператор % позволяет получить остаток от деления.
Пример 1:
x=5
результат: “5 лет”
Пример 2:
x=31
результат: “31 год”
Пример 3:
x=44
результат: “44 года”
<h2> Алгоритм решения </h2>
Получить последнюю цифру числа x с помощью операции x % 10.
Получить последние две цифры числа x с помощью операции x % 100.
Используя оператор switch или условные конструкции:
    Если последние две цифры равны 11, 12, 13 или 14, вернуть строку "x лет".
    Иначе, если последняя цифра равна 1, вернуть строку "x год".
    Иначе, если последняя цифра находится в диапазоне от 2 до 4, вернуть строку "x года".
    Во всех остальных случаях вернуть строку "x лет".

<h2> Вывод дней недели.</h2> 
Дана сигнатура метода: public void printDays (String x);
В качестве параметра метод принимает строку, в которой записано название
дня недели. Необходимо реализовать метод таким образом, чтобы он выводил
на экран название переданного в него дня и всех последующих до конца недели
дней. Если в качестве строки передан не день, то выводится текст “это не день
недели”. Первый день понедельник, последний – воскресенье. Вместо if в данной
задаче используйте switch.
Пример 1:
x=”четверг”
результат:
четверг
пятница
суббота
воскресенье
Пример 2:
x=”чг”
результат:
это не день недели
<h2> Алгоритм решения </h2>
Использовать оператор switch для сопоставления строки x с названиями дней недели.
Для каждого случая (case), начиная с переданного дня, вывести на экран этот день и все последующие до воскресенья.
Если ни один case не сработал, в блоке default вывести "это не день недели".


<h2> Числа наоборот.</h2> 
Дана сигнатура метода: public String reverseListNums (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой будут записаны все числа от x до 0 (включительно).
Пример:
x=5
результат: “5 4 3 2 1 0”
<h2> Алгоритм решения </h2>
Создать пустую строку-аккумулятор (или использовать StringBuilder).
В цикле, начиная от x и до 0 (включительно), на каждой итерации:
    Добавлять текущее число к строке-аккумулятору.
    Добавлять пробел после числа (кроме последней итерации).
Вернуть полученную строку.

<h2> Степень числа.</h2> 
Дана сигнатура метода: public int pow (int x, int y);
Необходимо реализовать метод таким образом, чтобы он возвращал результат
возведения x в степень y.
Подсказка: для получения степени необходимо умножить единицу на число x, и
сделать это y раз, т.е. два в третьей степени это 1*2*2*2
Пример:
x=2
y=5
результат: 32
<h2> Алгоритм решения </h2>
Создать переменную-аккумулятор (например, result) и инициализировать ее значением 1.
В цикле, который выполняется y раз, умножать result на x.
После завершения цикла вернуть значение result.

<h2> Одинаковость.</h2> 
Дана сигнатура метода: public bool equalNum (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
все знаки числа одинаковы, и false в ином случае.
Подсказки:
intx=123%10; // х будет иметь значение 3
intу=123/10; // у будет иметь значение 12
Пример 1:
x=1111
результат: true
Пример 2:
x=1211
результат: false
<h2> Алгоритм решения </h2>
Если число x равно 0, вернуть true (все цифры одинаковы).
Получить последнюю цифру числа x и сохранить ее как образец.
В цикле, пока x больше 0:
    На каждой итерации получать последнюю цифру x (x % 10).
    Сравнивать эту цифру с образцом. Если они не равны, вернуть false.
    Убирать последнюю цифру из числа x (x = x / 10).
Если цикл завершился, значит, все цифры были одинаковы. Вернуть true.


<h2> Левый треугольник.</h2> 
Дана сигнатура метода: public void leftTriangle (int x);
Необходимо реализовать метод таким образом, чтобы он выводил на экран
треугольник из символов ‘*’ у которого х символов в высоту, а количество
символов в ряду совпадает с номером строки.
Пример 1:
x=2
результат:
*
**
Пример 2:
x=4
результат:
*
**
***
****
<h2> Алгоритм решения </h2>
Создать внешний цикл, который выполняется x раз (для каждой строки). Переменная цикла i (от 1 до x).
Внутри внешнего цикла создать внутренний цикл, который выполняется i раз (для вывода i звездочек в строке i).
Внутри внутреннего цикла выводить символ '*' без перехода на новую строку.
После завершения внутреннего цикла вывести символ перевода строки.


<h2> Угадайка.</h2> 
Дана сигнатура метода: public void guessGame()
Необходимо реализовать метод таким образом, чтобы он генерировал
случайное число от 0 до 9, далее считывал с консоли введенное пользователем
число и выводил, угадал ли пользователь то, что было загадано, или нет. Метод
запускается до тех пор, пока пользователь не угадает число. После этого
выведите на экран количество попыток, которое потребовалось пользователю,
чтобы угадать число.
Пример:
Введите число от 0 до 9:
5
Вы не угадали, введите число от 0 до 9:
9
Вы угадали!
Вы отгадали число за 2 попытки
<h2> Алгоритм решения </h2>
Сгенерировать случайное число в диапазоне от 0 до 9. Создать счетчик попыток.
Создать цикл do-while или while с условием, что число не угадано.
Внутри цикла:
    Увеличить счетчик попыток на 1.
    Запросить у пользователя ввод числа.
    Сравнить введенное число с загаданным.
    Если числа не равны, сообщить пользователю об ошибке.
    Если числа равны, сообщить о победе и выйти из цикла.
После цикла вывести на экран количество попыток.


<h2> Поиск последнего значения.</h2> 
Дана сигнатура метода: public int findLast (int[] arr, int x);
Необходимо реализовать метод таким образом, чтобы он возвращал индекс
последнего вхождения числа x в массив arr. Если число не входит в массив –
возвращается -1.
Пример:
arr=[1,2,3,4,2,2,5]
x=2
результат: 5
<h2> Алгоритм решения </h2>
Пройти по массиву arr с конца к началу (от последнего индекса к нулевому).
На каждой итерации сравнивать текущий элемент массива с числом x.
Если элемент равен x, немедленно вернуть текущий индекс.
Если цикл завершился, а совпадение не найдено, вернуть -1.

<h2> Добавление в массив.</h2> 
Дана сигнатура метода: public int[]add (int[] arr, int x, int pos);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, который будет содержать все элементы массива arr, однако в позицию
pos будет вставлено значение x.
Пример:
arr=[1,2,3,4,5]
x=9
pos=3
результат: [1,2,3,9,4,5]
<h2> Алгоритм решения </h2>
Создать новый массив длиной arr.Length + 1.
Скопировать в новый массив все элементы из arr от начала до индекса pos - 1.
Записать значение x в новый массив по индексу pos.
Скопировать оставшиеся элементы из arr (начиная с индекса pos) в новый массив, начиная с индекса pos + 1.
Вернуть новый массив.

<h2> Реверс.</h2> 
Дана сигнатура метода: public void reverse (int[] arr);
Необходимо реализовать метод таким образом, чтобы он изменял массив arr.
После проведенных изменений массив должен быть записан задом-наперед.
Пример:
arr=[1,2,3,4,5]
результат: arr=[5,4,3,2,1]
<h2> Алгоритм решения </h2>
Создать цикл, который проходит до середины массива.
На каждой итерации менять местами элемент с текущего индекса i и элемент с симметричного индекса arr.Length - 1 - i.


<h2> Объединение.</h2> 
Дана сигнатура метода: public int[] concat (int[] arr1,int[] arr2);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором сначала идут элементы первого массива (arr1), а затем
второго (arr2).
Пример:
arr1=[1,2,3]
arr2=[7,8,9]
результат: [1,2,3,7,8,9]
<h2> Алгоритм решения </h2>
Создать новый массив длиной arr1.Length + arr2.Length.
Скопировать все элементы массива arr1 в начало нового массива.
Скопировать все элементы массива arr2 в новый массив, начиная с индекса arr1.Length.
Вернуть новый массив.

<h2> Удалить негатив.</h2> 
Дана сигнатура метода: public int[] deleteNegative (int[] arr);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором записаны все элементы массива arr кроме отрицательных.
Пример:
arr=[1,2,-3,4,-2,2,-5]
результат: [1,2,4,2]
<h2> Алгоритм решения </h2>
Подсчитать количество неотрицательных элементов в массиве arr.
Создать новый массив длиной, равной найденному количеству.
Пройти по исходному массиву arr и скопировать все неотрицательные элементы в новый массив.
Вернуть новый массив.
